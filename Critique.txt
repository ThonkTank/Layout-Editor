# Layout Editor Plugin – Strukturanalyse und Kritik

## 1. Architektur und Verantwortlichkeiten

### 1.1 Modulbasierte Editor-Architektur
- Der frühere `LayoutEditorView`-Monolith wurde in Presenter-, Store- und Komponentenmodule aufgeteilt. Ein zentraler UI-Store steuert die Zustände für Canvas, Inspector und Tree und synchronisiert Presenter über reaktive Events.
- Spezialisierte Presenter (Stage, Inspector, Library) besitzen klar definierte Lebenszyklen und kapseln Event-Bindings. Das verringert Seiteneffekte und erleichtert gezielte Tests.
- Die UI-Komponenten liegen als wiederverwendbare Module mit klaren Render-Funktionen vor; Styling- und Event-Hooks bleiben pro Komponente gebündelt.

### 1.2 Komponentenbasierte UI-Komposition
- Panels, Toolbars und Dialoge werden jetzt über modulare Komponenten instanziiert. Utility-Factories kapseln DOM-Erzeugung, und Presenter interagieren ausschließlich über deklarierte Inputs/Outputs.
- Gemeinsame UI-Verhalten (Resize, Drag & Drop, Fokusverwaltung) sind in dedizierten Services gebündelt, sodass Änderungen an einer Stelle propagiert werden.
- Durch die modulare Struktur ist das Hinzufügen neuer Panels (z. B. Datenquellen) ohne Eingriff in Kernansichten möglich.

-----------------------------------------------------------------------------------

### 1.3 LayoutTree-Modell und DomainConfiguration-Service
- Das Datenmodell basiert nun auf `LayoutTree`, das Elemente als Baum mit ID-Index, Parent/Child-Referenzen und Snapshot-APIs verwaltet. Mutationen laufen über transaktionale Commands, wodurch Historie und Persistenz konsistent bleiben.
- `LayoutTree` ermöglicht O(1)-Zugriffe auf Elemente und Knotenoperationen (Move, Clone, Delete) über strukturierte Helper, was Performance-Engpässe beseitigt.
- Die neue `DomainConfiguration`-Schicht lädt Attribute, Kategorien und Seed-Layouts aus Vault- oder Remote-Quellen. Sie injiziert Definitionsdaten in den Editor und versieht sie mit Validierung sowie Namespacing.

## 2. Funktionalität und Erweiterbarkeit

### 2.1 DomainConfiguration-Service
- Der Domain-Layer wird über `DomainConfiguration` versorgt, das Layout-Definitionen, Feldsets und Startlayouts modular lädt.
- Konfigurationen können aus lokalen Dateien oder Remote-Quellen injiziert werden; Validierung verhindert fehlerhafte Registrierungen.
- Domänenspezifische Erweiterungen lassen sich nun als eigenständige Pakete pflegen, statt hart in den Code eingebettet zu sein.

### 2.2 Keine Versionierung der öffentlichen API
- `LayoutEditorPluginApi` wird ohne Versionsangabe exportiert (`src/main.ts`, Zeilen 26–72). Änderungen an den Signaturen würden Dritt-Plugins sofort brechen.
- Empfehlung: Eine `apiVersion`-Kennung sowie Deprecation-Strategie einführen und Dokumentation in README ergänzen.
- _Update 2024-05-23_: Die Dokumentation in `layout-editor/docs/plugin-api.md` beschreibt API-Versionierung und Methoden. Eine technische Strategie zur Deprecation (z. B. getrennte Version-Pipelines) fehlt weiterhin.

### 2.3 Fehlende Validierung bei Element-Definitionen
- `registerLayoutElementDefinition` akzeptiert Definitionen ohne Pflichtfelder jenseits von `type` (`src/definitions.ts`, Zeilen 76–86). Fehlerhafte Register-Aufrufe können zur Laufzeit ungültige UI erzeugen, da `renderAddElementControl` keine defensiven Checks hat (`src/view.ts`, Zeilen 226–320).
- Vorschlag: Schema-Validierung (z. B. Zod) einführen und fehlerhafte Definitionen ablehnen.

## 3. Robustheit und Performance

### 3.1 Unbegrenzte Undo/Redo-Historie
- `LayoutHistory` speichert jede Mutation als Vollkopie aller Elemente (`src/history.ts`, Zeilen 5–70). Bei komplexen Layouts wächst der Speicherbedarf stark, Undo/Redo wird langsam.
- Lösung: Limitierte Historie (z. B. 50 Schritte) und differenzbasierte Snapshots oder strukturierte Patches statt Deep-Clones.

### 3.2 Ineffiziente Re-Renders
- `renderElements()` iteriert bei jeder Änderung über alle Elemente, erzeugt fehlende DOM-Knoten und rendert den kompletten Baum erneut (`src/view.ts`, Zeilen 681–705). Der Strukturbaum wird vollständig neu aufgebaut (`src/view.ts`, Zeilen 871–1042).
- Bei vielen Elementen führt das zu merkbaren Jank-Effekten. Ein diff-basiertes Rendering oder Virtual DOM würde Performance stabilisieren.

### 3.3 Event-Listener ohne Lifecycle-Kapselung
- Einige Listener werden direkt am DOM registriert (`stageViewportEl.addEventListener(...)`, `src/view.ts`, Zeilen 300–307; Drag-Events Zeilen 929–1035). Obwohl das DOM beim Schließen entfernt wird, fehlt eine zentrale Cleanup-Routine. Sollte `render()` erneut aufgerufen werden (z. B. bei Theme-Wechseln), würden Listener dupliziert.
- Verbesserung: Konsistente Nutzung von `this.registerDomEvent` oder eine dedizierte `disposeStage()`-Methode.

### 3.4 Fehlende Fehleroberfläche bei Persistenz
- `saveLayoutToLibrary` wirft Fehler (z. B. ungültige ID) (`src/layout-library.ts`, Zeilen 60–104), aber die View zeigt nur einen generischen `Notice` (`src/view.ts`, Zeilen 1328–1360). Benutzer erfahren keine Details.
- Empfehlung: Fehlerdetails im UI anzeigen und Logging strukturieren.

## 4. Codequalität und Wartbarkeit

### 4.1 Tooling und Testabdeckung
- CI führt `lint`, `type-check` und `test`-Skripte aus. ESLint/Prettier sichern Stil- und Qualitätsvorgaben, während Vitest-Suiten die Stores, Presenter und `LayoutTree`-Operationen abdecken.
- Snapshot-Tests für Komponenten prüfen UI-Regressionsrisiken; zusätzliche Integrationstests validieren Domain-Konfigurationen.

### 4.2 Typen nur als Alias
- `LayoutElementType` ist ein Alias für `string` (`src/types.ts`, Zeile 3). Dadurch erkennen Tools falsche Typen nicht (z. B. Tippfehler bei `view-container`).
- Lösung: Literal-Typen aus den Registries generieren oder `as const`-Manifeste exportieren.

### 4.3 Redundante State-Information
- `LayoutElement` pflegt sowohl `parentId` als auch `children` (`src/types.ts`, Zeilen 12–36). Die manuelle Synchronisierung verursacht zusätzliche Fehlerquellen (`src/view.ts`, Zeilen 646–676 und 1075–1113).
- Empfehlung: Eine eindeutige Quelle der Wahrheit definieren (z. B. nur `parentId` speichern und Kinder dynamisch ableiten).

### 4.4 Fehlende Trennung von UI-Texten
- UI-Texte sind direkt im Code eingebettet (z. B. deutsche Strings im Inspector `src/inspector-panel.ts`, Zeilen 39–132). Internationalisierung oder Anpassung ist so kaum möglich.
- Vorschlag: Strings in Ressourcen-Dateien oder Locale-Module auslagern.

## 5. Technische Schulden und Risiken

### 5.1 Outstanding Issues (Stand aktuell)
- **Export-Thrashing:** Der automatische Export-Trigger feuert bei jedem Store-Tick und verursacht unnötige Vault-Schreiblast. Ein Debounce bzw. eine Export-Queue fehlt weiterhin.
- **Domain-Source-Toggle fehlt:** Anwender können Domänenkonfigurationen nicht zwischen Vault und Remote-Quelle umschalten. Ein Settings-Flag bzw. ein Toggle im Domain-Panel ist noch offen.

## 6. Zusammenfassung
Der Editor verfügt inzwischen über eine modularisierte Store/Presenter/Komponenten-Architektur, ein performantes `LayoutTree`-Modell und konfigurierbare Domänen über den `DomainConfiguration`-Service. Qualitätssicherung durch Linting und Tests ist etabliert. Priorität behalten jedoch das Debouncen der Export-Pipeline sowie ein Toggle für die Quelle der Domänenkonfigurationen, damit Integrationen stabil bleiben.
