# Layout Editor – Overview

Der Layout Editor wird weiterhin als eigenständiges Obsidian-Plugin ausgeliefert. `main.ts` registriert den View, injiziert das
Style-Sheet aus `css.ts` und stellt über `index.ts` eine API für andere Erweiterungen bereit. Seit dieser Iteration wurde der
View intern modularisiert: Ein zentraler Store verwaltet alle Editor-Zustände, spezialisierte Presenter rendern Bühne,
Struktur-Panel und Header/Export-Bereich, während `view.ts` nur noch als Koordinator fungiert.

## Struktur

```
plugins/layout-editor/
├─ manifest.json          # Obsidian-Manifest, verweist auf das gebündelte main.js
├─ esbuild.config.mjs     # Build-Skript (bundelt src/main.ts → main.js)
├─ package.json           # Dev-Abhängigkeiten + Build- & Test-Skripte
├─ package-lock.json      # Feste Auflösung der Abhängigkeiten
├─ tsconfig.json          # TypeScript-Konfiguration des Plugins
├─ .gitignore             # Ignoriert node_modules und Build-Artefakte aus den Tests
├─ tests/                 # Minimale Test-Infrastruktur
│  ├─ layout-editor-store.test.ts  # Store-Spezifikation (Drag/Drop, Undo/Redo)
│  └─ run-tests.mjs                # Bundelt Tests via esbuild und führt sie mit Node aus
└─ src/
   ├─ LayoutEditorOverview.txt  # Diese Übersicht
   ├─ main.ts             # Plugin-Bootstrap (View registrieren, Ribbon/Command, API, CSS-Injektion)
   ├─ css.ts              # Layout-Editor-Styling als Template-String
   ├─ index.ts            # Öffentliche Re-Exports (Plugin, API, Registry, Library)
   ├─ types.ts            # Gemeinsame Typen für Elemente, Container & Snapshots
   ├─ utils.ts            # Hilfsfunktionen (clamp, Deep-Clones, Vergleichs-Utilities)
   ├─ history.ts          # Undo/Redo-Verwaltung für LayoutSnapshots
   ├─ state/
   │  └─ layout-editor-store.ts # Zentraler Zustand (Canvas, Elemente, History, Drag-State, Persistenz-Metadaten)
   ├─ presenters/
   │  ├─ header-controls.ts  # Header + Export-Bereich (Element hinzufügen, Import/Export, Canvas-Größe, Speichern)
   │  ├─ stage-controller.ts # Canvas & Kamera (Rendern, Pointer-Interaktionen, Zoom/Pan, Move/Resize)
   │  └─ structure-panel.ts  # Struktur-Baum mit Drag & Drop und Kamera-Fokus
   ├─ view.ts            # Dünner Koordinator: Presenter instanziieren, Store-Events abonnieren, Inspector anbinden
   ├─ attribute-popover.ts # Attribute-Popover inkl. Events & Sync zurück zum Store
   ├─ inspector-panel.ts   # Inspector-Rendering (Formfelder, Container-Steuerung, Attribute-Trigger)
   ├─ element-preview.ts   # Canvas-Vorschau delegiert an Element-Komponenten
   ├─ inline-edit.ts       # Generischer ContentEditable-Editor für Inline-Bearbeitung
   ├─ definitions.ts       # Element-/Attribut-Registry + Label-Helfer & Defaults
   ├─ view-registry.ts     # Registry für View-Bindings externer Features
   ├─ elements/
   │  ├─ base.ts           # Interfaces für Komponenten (Preview-/Inspector-Kontext)
   │  ├─ registry.ts       # Lädt alle Komponenten aus ./components
   │  ├─ component-manifest.ts # Auto-generiert: Verzeichnis aller Komponenten
   │  ├─ components/       # Drop-in-Komponenten pro Elementtyp (Preview, Inspector, Defaults)
   │  └─ shared/           # Gemeinsame Basisklassen & Container-Preview
   ├─ elements/ui.ts      # UI-Komponenten (Buttons, Felder, Status) für View & Modals
   ├─ element-picker-modal.ts  # Element-Browser zum Hinzufügen neuer Typen
   ├─ layout-library.ts        # Persistenz-Layer für gespeicherte Layouts (Vault JSON)
   ├─ layout-picker-modal.ts   # Modal zur Auswahl gespeicherter Layouts
   ├─ name-input-modal.ts      # Leichtgewichtiger Modal zum Benennen neuer Layouts
   ├─ search-dropdown.ts       # Autocomplete-Helfer für Select-Elemente
   ├─ seed-layouts.ts          # Legt Standard-Layouts im Vault an (z. B. Kreaturenvorlage)
   └─ ui/
      ├─ editor-menu.ts        # Kontextmenü für Inspector & Schnellaktionen
      └─ element-tree.ts       # Generische Baumansicht für den Element-Browser
```

## Features & Verantwortlichkeiten

- **Plugin-Bootstrap (`main.ts`)** registriert den `LayoutEditorView`, richtet Ribbon/Command ein und stellt über `getApi()` ein
  `LayoutEditorPluginApi` bereit (View öffnen, Registry-Hooks, Layout-Library).
- **Zentraler Zustand (`state/layout-editor-store.ts`)** verwaltet Canvas-Maße, Elemente, Auswahl, Drag-Zustände sowie History.
  Alle Mutationen (Elemente anlegen, Container-Layouts anwenden, Undo/Redo, Layout-Metadaten) laufen über den Store, der bei
  jeder Änderung Events an die Presenter aussendet.
- **Presenter-Schicht:**
  - `stage-controller.ts` baut den Canvas inklusive Kamera auf, rendert Element-Nodes und verarbeitet Pointer-Interaktionen
    (Move/Resize, Zoom, Pan). Änderungen schreibt er ausschließlich über Store-Methoden zurück.
  - `structure-panel.ts` generiert den Baum, delegiert Drag & Drop an den Store und nutzt den Stage-Controller, um Elemente in
    den Fokus zu setzen.
  - `header-controls.ts` zeichnet Header und Exportbereich, synchronisiert Canvas-Größen, öffnet Element-/Layout-Picker und
    orchestriert Import/Export sowie Speichern (inkl. Metadaten-Updates im Store).
- **`view.ts` als Koordinator:** instanziiert Store und Presenter, bindet Inspector und Attribute-Popover an Store-Ereignisse,
  reagiert auf globale Shortcuts (Delete, Undo/Redo) und hält die Panel-Resizer auf Kurs.
- **Inspector & Inline-Bearbeitung:** `inspector-panel.ts`, `attribute-popover.ts` und `inline-edit.ts` sorgen weiterhin dafür,
  dass Canvas, Inspector und Attribute synchron bleiben. Sie pushen Änderungen nur noch über den Store, wodurch History und
  Presenter automatisch aktualisiert werden.
- **Komponentenbasierte Elemente:** Unter `elements/` bleiben Preview-, Inspector- und Default-Logik je Elementtyp gekapselt.
  Container-, Select- und Textfeld-Elemente erben gemeinsames Verhalten aus `shared/component-bases.ts`.
- **Layout-Bibliothek & Export:** `header-controls.ts` erzeugt JSON-Exporte im gleichen Format wie `layout-library.ts` sie
  speichert (`LayoutBlueprint` + Metadaten). Importierte Layouts setzen State und History über den Store zurück.
- **Tests:** `tests/run-tests.mjs` bündelt `layout-editor-store.test.ts` via esbuild. Der Test deckt Drag/Drop via Store-Aktion,
  Undo/Redo und Delete-Flows ab und stellt sicher, dass Subskriptionen Events erhalten.

## Datenfluss

1. **UI-Interaktionen** (Canvas, Struktur, Header, Inspector) rufen Store-Methoden auf.
2. **`LayoutEditorStore`** aktualisiert den Zustand, verwaltet History und sendet Change-/Export-Events.
3. **Presenter & `view.ts`** hören auf Store-Events, aktualisieren DOM (Canvas, Strukturbaum, Inspector, Status) und halten die
   Oberfläche synchron.
4. **Registry-Updates** (`definitions.ts`, `view-registry.ts`) fließen über Presenter und Inspector zurück in den Store.
5. **Layout-Library**-Aktionen laufen über `header-controls.ts`, das nach erfolgreichem Import/Speichern Metadaten im Store
   aktualisiert.

## Dateibeschreibungen

### `main.ts`
- Bootstrap des Plugins: registriert View, Ribbon-Icon und Command.
- Stellt `LayoutEditorPluginApi` bereit (View öffnen, Registry-/Library-Methoden).
- Kümmert sich um CSS-Injektion und Cleanup beim Unload.

### `css.ts`
- Enthält das komplette Layout-Editor-Styling als Template-String.
- Wird ausschließlich vom Layout-Editor-Plugin geladen, um Konflikte zu vermeiden.

### `index.ts`
- Re-exportiert Plugin-Klasse, API-Typen sowie Registry-/Library-Helfer.

### `state/layout-editor-store.ts`
- Hält Canvas-Größe, Elemente, Auswahl, Drag-State und History zusammen.
- Bietet sämtliche Mutations-Methoden (Elemente anlegen/löschen, Container-Layout anwenden, Move/Resize, Undo/Redo,
  Persistenz-Metadaten) und serialisiert den aktuellen Blueprint.
- Benachrichtigt Presenter über State- und Export-Events.

### `presenters/header-controls.ts`
- Rendert Header + Exportbereich.
- Öffnet Element- und Layout-Picker, verwaltet Canvas-Größen, Import/Export sowie Speichern inkl. Statusanzeigen.

### `presenters/stage-controller.ts`
- Baut den Canvas samt Kamera auf, rendert Element-Nodes und synchronisiert Preview-Inhalte.
- Verarbeitet Pointer-Interaktionen (Move, Resize, Zoom, Pan) und meldet Änderungen ausschließlich über den Store.

### `presenters/structure-panel.ts`
- Erzeugt den Strukturbaum, erlaubt Drag & Drop zwischen Containern und fokussiert Elemente auf der Bühne.
- Delegiert alle Mutationen an den Store.

### `view.ts`
- Dünner Koordinator (`ItemView`): instanziiert Store + Presenter, reagiert auf Store-Events und hält Inspector/Popover aktuell.
- Verwaltet Panel-Resizer sowie globale Shortcuts (Delete, Undo/Redo).

### `inspector-panel.ts`
- Rendert Inspector-Formulare, ruft Store-Methoden für Layout-Anpassungen auf und nutzt die Attribute-Popover-Hooks.

### `attribute-popover.ts`
- Öffnet und positioniert das Attribut-Popover, synchronisiert Änderungen über den Store und triggert Inspector-Refresh.

### `layout-library.ts`, `layout-picker-modal.ts`, `name-input-modal.ts`
- Unverändert: Speichern/Laden von Layouts, Dialog zum Auswählen vorhandener Layouts, Modal für Layout-Namen.

### `tests/layout-editor-store.test.ts`
- Prüft `LayoutEditorStore` auf elementares Verhalten (Container-Defaults, Drag & Drop via Store, Undo/Redo, Delete).
- Nutzt die esbuild-basierte Test-Infrastruktur (`tests/run-tests.mjs`).

